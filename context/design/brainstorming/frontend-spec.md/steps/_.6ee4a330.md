---
timestamp: 'Wed Oct 29 2025 07:06:13 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251029_070613.77de349e.md]]'
content_id: 6ee4a330c5382c764f38364127cf64169bfe0bfa0fd0a0ad755c467b789056e2
---

# Concept Specifications

## concept: UserAuthentication \[User]

* **purpose**: To securely verify a user's identity based on credentials.
* **principle**: If you register with a unique username and a password, and later provide the same credentials to log in, you will be successfully identified as that user.
* **state**:
  * a set of `User`s with
    * a `username` String (unique)
    * a `passwordHash` String
* **actions**:
  * `register (username: String, password: String): (user: User)`
    * **requires**: no User exists with the given `username`.
    * **effects**: creates a new User `u`; sets their `username` and a hash of their `password`; returns `u` as `user`.
  * `register (username: String, password: String): (error: String)`
    * **requires**: a User already exists with the given `username`.
    * **effects**: returns an error message.
  * `login (username: String, password: String): (user: User)`
    * **requires**: a User exists with the given `username` and the `password` matches their `passwordHash`.
    * **effects**: returns the matching User `u` as `user`.
  * `login (username: String, password: String): (error: String)`
    * **requires**: no User exists with the given `username` or the `password` does not match.
    * **effects**: returns an error message.
* **queries**:
  * `_getUserByUsername (username: String): (user: User)`
    * **requires**: a User with the given `username` exists.
    * **effects**: returns the corresponding User.

## concept: Sessioning \[User, Session]

* **purpose**: To maintain a user's logged-in state across multiple requests without re-sending credentials.
* **principle**: After a user is authenticated, a session is created for them. Subsequent requests using that session's ID are treated as being performed by that user, until the session is deleted (logout).
* **state**:
  * a set of `Session`s with
    * a `user` User
* **actions**:
  * `create (user: User): (session: Session)`
    * **requires**: true.
    * **effects**: creates a new Session `s`; associates it with the given `user`; returns `s` as `session`.
  * `delete (session: Session): ()`
    * **requires**: the given `session` exists.
    * **effects**: removes the session `s`.
* **queries**:
  * `_getUser (session: Session): (user: User)`
    * **requires**: the given `session` exists.
    * **effects**: returns the user associated with the session.

## concept: FileStorage \[User, File]

* **purpose**: To store and manage files, with a clear notion of ownership.
* **principle**: When a user uploads a file, they become its owner. The owner can later retrieve or delete the file.
* **state**:
  * a set of `File`s with
    * an `owner` User
    * a `filename` String
    * a `content` String (or binary data)
* **actions**:
  * `upload (owner: User, filename: String, content: String): (file: File)`
    * **requires**: true.
    * **effects**: creates a new File `f`; sets its `owner`, `filename`, and `content`; returns `f` as `file`.
  * `delete (file: File): ()`
    * **requires**: the given `file` exists.
    * **effects**: removes the file `f`.
* **queries**:
  * `_getOwner (file: File): (owner: User)`
    * **requires**: the given `file` exists.
    * **effects**: returns the owner of the file.
  * `_getFileContent (file: File): (filename: String, content: String)`
    * **requires**: the given `file` exists.
    * **effects**: returns the filename and content of the file.
  * `_getFilesByOwner (owner: User): (file: File, filename: String)`
    * **requires**: the given `owner` exists.
    * **effects**: returns all files owned by the user, along with their filenames.

## concept: Sharing \[User, File]

* **purpose**: To allow file owners to grant access to other users.
* **principle**: A file's owner can share it with another user, who can then access it. If the owner revokes access, the other user can no longer access it.
* **state**:
  * a set of `File`s with
    * a `sharedWith` set of User
* **actions**:
  * `shareWithUser (file: File, user: User): ()`
    * **requires**: `user` is not already in the `sharedWith` set for `file`.
    * **effects**: adds the `user` to the `sharedWith` set for `file`.
  * `revokeAccess (file: File, user: User): ()`
    * **requires**: `user` is in the `sharedWith` set for `file`.
    * **effects**: removes the `user` from the `sharedWith` set for `file`.
* **queries**:
  * `_hasAccess (file: File, user: User): (access: Boolean)`
    * **requires**: `file` and `user` exist.
    * **effects**: returns `true` if the `user` is the owner of the `file` (checked via `FileStorage`) OR if the `user` is in the `sharedWith` set for the `file`. *Note: This query implies a cross-concept read during implementation, which is a powerful pattern.* A pure version would require the sync to do the join. Let's make it pure for a better example.
  * `_isSharedWith (file: File, user: User): (access: Boolean)` (Revised pure query)
    * **requires**: `file` and `user` exist.
    * **effects**: returns `true` if the `user` is in the `sharedWith` set for the `file`, false otherwise.

***
